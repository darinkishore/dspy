# Sweep AI turns bugs & feature requests into code changes (https://sweep.dev)
# For details on our config file, check out our docs at https://docs.sweep.dev/usage/config

# This setting contains a list of rules that Sweep will check for. If any of these rules are broken in a new commit, 
# Sweep will create a pull request to fix the broken rule.
rules:
  - "All new business logic should have corresponding unit tests."
  - "Refactor large functions to be more modular."
  - "Add docstrings to all functions and file headers in python files."
  - "Ensure that any new modules or features adhere to the DSPy framework's syntax and module structure."
  - "Maintain modularity and declarative style as per DSPy's design philosophy."
  - "All new capabilities or changes should be reflected in the documentation `docs/`."
  
# This is the branch that Sweep will develop from and make pull requests to. Most people use 'main' or 'master' but some users also use 'dev' or 'staging'.
branch: 'main'


# By default Sweep will read the logs and outputs from your existing Github Actions. To disable this, set this to false.
gha_enabled: True

# This is the description of your project. It will be used by sweep when creating PRs. You can tell Sweep what's unique about your project, what frameworks you use, or anything else you want.
#
# Example:
#
# description: sweepai/sweep is a python project. The main api endpoints are in sweepai/api.py. Write code that adheres to PEP8.
description: 'DSPy is a versatile and sophisticated Python framework designed to facilitate complex interactions with language models (LMs) and retrieval models. The framework is built with the purpose of enabling users to achieve advanced linguistic tasks, ranging from basic natural language understanding to intricate chain-of-thought reasoning and programmatic outputs. DSPy stands out for its modularity, allowing for systematic optimization and integration of different components, which include:\n- **Modular Design**: DSPy adopts a modular architecture that enables developers to plug in various language and retrieval models as well as teleprompting strategies. This design allows for the easy swapping and upgrading of modules based on task requirements.\n- **Teleprompters and Compilers**: The framework includes teleprompter modules for prompt engineering and a compiler capable of automatically adapting tasks to the optimal prompting strategy. This enables efficient utilization of LMs without extensive manual prompt crafting.\n- **Fine-Tuning and Model Adaptation**: DSPy provides mechanisms for fine-tuning LMs to the needs of specific tasks or datasets, enhancing model performance and adaptability.\n- **Chain-of-Thought and Reasoning**: The system supports various reasoning methods, including Chain of Thought and Program of Thought approaches, which foster step-by-step problem-solving abilities in LMs.\n- **Self-Improvement Through Learning**: DSPy can incorporate learning and self-improvement loops, where the LM learns from previous interactions and improves over time.\n- **Performance Evaluation**: Built-in evaluation modules in DSPy allow for the measurement and tracking of LMs' performance against benchmarks and datasets.\n- **Dataset and Retrieval Integration**: Users can integrate retrieval models and datasets, facilitating advanced tasks that require external knowledge sourcing.\n- **Pythonic Interface**: The Pythonic syntax for module composition streamlines the task-specific assembly of building blocks and supports ease of use and developer intuition.\n- **Automated Optimization**: Systematic optimization features such as signature optimization and automatic parameter tuning are provided to enhance the effectiveness of LMs for the given tasks.\nWhat to know before working on any task in DSPy:\n- **Understanding of Signature Mechanism**: It's essential to comprehend how DSPy utilizes signatures to define the input/output behavior of tasks and how they form the basis for interaction with LMs.\n- **Familiarity with Module Composition**: Given the framework's modular nature, knowledge of how different modules interlink and the ability to navigate the codebase are critical.\n- **Compiler Workflow**: Acknowledgment of the compiler's role in prompt construction and adaptation is key to working within DSPy, as it affects how tasks are structured and deployed.\n- **Teleprompting Strategies**: Awareness of various teleprompting techniques available within DSPy is vital for efficient prompt engineering.\n- **Evaluation Protocols**: Know the protocols for evaluating LMs' output for correctness, coherence, novelty, and alignment with task specifications.\n- **Adherence to Design Principles**: Conform to the established principles of the DSPy framework, including modularity, systematic optimization, and extensibility.\nDSPy's comprehensive ecosystem enables researchers, developers, and practitioners to leverage the power of state-of-the-art language and retrieval models for developing cutting-edge applications in NLP and beyond.'

# This sets whether to create pull requests as drafts. If this is set to True, then all pull requests will be created as drafts and GitHub Actions will not be triggered.
draft: False

# This is a list of directories that Sweep will not be able to edit.
blocked_dirs: [./sweep.yaml]

# This is a list of documentation links that Sweep will use to help it understand your code. You can add links to documentation for any packages you use here.
#
# Example:
#
# docs:
#   - PyGitHub: ["https://pygithub.readthedocs.io/en/latest/", "We use pygithub to interact with the GitHub API"]
docs:
  - DSPy: ["https://github.com/stanfordnlp/dspy/docs", "Main repository for the DSPy framework"]
  - ReadTheDocs: ["https://docs.readthedocs.io/en/stable/index.html", "ReadTheDocs, hosts our documentation"]
